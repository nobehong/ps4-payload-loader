<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CHRONOS-USB | WebKit Binary Execution</title>
    <style>
        :root {
            --webkit-blue: #0066cc;
            --webkit-green: #00cc66;
            --webkit-purple: #9933cc;
            --danger: #ff3333;
            --warning: #ffaa00;
            --dark: #0a0a0a;
            --terminal: #000;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Monaco', 'Consolas', monospace;
            background: linear-gradient(135deg, #000000 0%, #001a33 100%);
            color: #00ff00;
            height: 100vh;
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
        }
        
        /* WebKit-specific enhancements */
        @supports (-webkit-backdrop-filter: blur(10px)) {
            .panel {
                -webkit-backdrop-filter: blur(10px);
                backdrop-filter: blur(10px);
            }
        }
        
        .header {
            background: rgba(0, 0, 0, 0.9);
            border-bottom: 2px solid #00ff00;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .logo h1 {
            font-size: 1.5rem;
            letter-spacing: 2px;
            text-shadow: 0 0 10px #00ff00;
        }
        
        .status-bar span {
            margin-left: 20px;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.9rem;
            background: rgba(255, 51, 51, 0.2);
            border: 1px solid #ff3333;
        }
        
        .container {
            display: grid;
            grid-template-columns: 300px 1fr 350px;
            height: calc(100vh - 60px);
            gap: 10px;
            padding: 10px;
        }
        
        .panel {
            background: rgba(10, 20, 30, 0.8);
            border: 1px solid #0066cc;
            border-radius: 5px;
            overflow: hidden;
        }
        
        .panel-header {
            background: rgba(0, 51, 102, 0.7);
            padding: 10px;
            border-bottom: 1px solid #00cc66;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .file-list {
            padding: 10px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .file-item {
            padding: 8px;
            margin: 5px 0;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid #333;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .file-item:hover {
            border-color: #00ff00;
            background: rgba(0, 255, 0, 0.1);
        }
        
        .terminal {
            background: #000;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            padding: 15px;
            height: calc(100% - 120px);
            overflow-y: auto;
            line-height: 1.4;
        }
        
        .terminal-line {
            margin: 5px 0;
        }
        
        .prompt {
            color: #00ccff;
            font-weight: bold;
        }
        
        .memory-viewer {
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            height: 200px;
            overflow-y: auto;
            background: #000;
        }
        
        .memory-line {
            display: grid;
            grid-template-columns: 100px 1fr auto;
            gap: 10px;
            margin: 2px 0;
        }
        
        .memory-address {
            color: #ffaa00;
        }
        
        .memory-hex {
            color: #00ff00;
        }
        
        .memory-ascii {
            color: #00ccff;
        }
        
        button {
            background: #0066cc;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            transition: all 0.2s;
        }
        
        button:hover {
            background: #0055aa;
            transform: translateY(-1px);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .btn-danger {
            background: #ff3333;
        }
        
        .btn-danger:hover {
            background: #cc0000;
        }
        
        .cursor {
            animation: blink 1s infinite;
        }
        
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }
        
        /* WebKit scrollbar styling */
        ::-webkit-scrollbar {
            width: 10px;
        }
        
        ::-webkit-scrollbar-track {
            background: #001122;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #0066cc;
            border-radius: 5px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #00cc66;
        }
    </style>
    
    <!-- WebKit-specific meta tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-title" content="CHRONOS-USB">
</head>
<body>
    <div class="header">
        <div class="logo">
            <h1>‚ö° CHRONOS-USB v1.0</h1>
        </div>
        <div class="status-bar">
            <span id="status">üî¥ OFFLINE</span>
            <span id="security">‚ö†Ô∏è SANDBOX ACTIVE</span>
        </div>
    </div>
    
    <div class="container">
        <!-- Left Panel - File System -->
        <div class="panel">
            <div class="panel-header">
                <h3>üìÅ USB FILE SYSTEM</h3>
                <button onclick="scanUSB()">SCAN</button>
            </div>
            <div class="file-list" id="fileList">
                <!-- Files will appear here -->
            </div>
            <div style="padding: 10px;">
                <input type="file" id="fileInput" multiple style="display: none;" onchange="handleFileSelect(event)">
                <button onclick="document.getElementById('fileInput').click()" style="width: 100%; margin-bottom: 10px;">
                    üì§ UPLOAD BINARIES
                </button>
                <button onclick="mountVirtualUSB()" style="width: 100%;">
                    üîß MOUNT VIRTUAL USB
                </button>
            </div>
        </div>
        
        <!-- Center Panel - Terminal -->
        <div class="panel">
            <div class="panel-header">
                <h3>üíª EXECUTION TERMINAL</h3>
                <div>
                    <button onclick="clearTerminal()">CLEAR</button>
                    <button onclick="toggleExecution()" id="execBtn">‚è∏Ô∏è PAUSE</button>
                </div>
            </div>
            <div class="terminal" id="terminal">
                <!-- Terminal output goes here -->
            </div>
            <div style="padding: 10px; display: flex; gap: 10px;">
                <input type="text" id="commandInput" placeholder="Enter command..." style="flex: 1; padding: 8px; background: #000; color: #00ff00; border: 1px solid #0066cc; border-radius: 4px;" onkeypress="handleCommandKey(event)">
                <button onclick="sendCommand()">EXECUTE</button>
                <button class="btn-danger" onclick="killProcess()">KILL</button>
            </div>
        </div>
        
        <!-- Right Panel - System Info -->
        <div class="panel">
            <div class="panel-header">
                <h3>‚öôÔ∏è SYSTEM MONITOR</h3>
                <button onclick="refreshMemory()">üîÑ</button>
            </div>
            <div class="memory-viewer" id="memoryViewer">
                <!-- Memory content goes here -->
            </div>
            <div style="padding: 10px;">
                <h4 style="margin-bottom: 10px;">üß¨ ACTIVE PROCESSES</h4>
                <div id="processList"></div>
            </div>
        </div>
    </div>

<script>
// ============================================================================
// CORE WEBKIT BINARY EXECUTION ENGINE
// ============================================================================

class ChronosEngine {
    constructor() {
        this.memory = new WebAssembly.Memory({ initial: 256, maximum: 1024 });
        this.stack = new ArrayBuffer(1024 * 1024); // 1MB stack
        this.heap = new ArrayBuffer(16 * 1024 * 1024); // 16MB heap
        this.modules = new Map();
        this.processes = [];
        this.files = [];
        this.isRunning = false;
        
        // WebKit-specific feature detection
        this.webkitFeatures = {
            hasWebUSB: 'usb' in navigator,
            hasFileSystem: 'webkitRequestFileSystem' in window,
            hasWASM: typeof WebAssembly === 'object',
            hasSIMD: WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0]))
        };
    }
    
    async initialize() {
        logTerminal("üöÄ CHRONOS-USB ENGINE INITIALIZING...");
        logTerminal("‚è≥ Detecting WebKit features...");
        
        // Check WebKit version
        const webkitVersion = detectWebKitVersion();
        logTerminal(`üì± WebKit Version: ${webkitVersion}`);
        
        // Initialize WebAssembly runtime
        if (this.webkitFeatures.hasWASM) {
            logTerminal("‚úÖ WebAssembly 1.0+ Support: ACTIVE");
            
            // Load core execution module
            try {
                await this.loadCoreWASM();
            } catch (e) {
                logTerminal(`‚ùå Failed to load WASM core: ${e.message}`);
            }
        } else {
            logTerminal("‚ùå WebAssembly Support: MISSING");
        }
        
        // Initialize virtual filesystem
        await this.initFilesystem();
        
        // Start system monitor
        this.startSystemMonitor();
        
        logTerminal("‚úÖ CHRONOS-USB READY FOR BINARY EXECUTION");
        logTerminal("üí° Type 'help' for available commands");
        
        updateStatus("üü¢ ONLINE");
    }
    
    async loadCoreWASM() {
        // Create a minimal WASM module for binary execution
        const wasmCode = new Uint8Array([
            0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, // WASM magic
            0x01, 0x04, 0x01, 0x60, 0x00, 0x00, // type section
            0x03, 0x02, 0x01, 0x00, // function section
            0x07, 0x08, 0x01, 0x04, 0x6d, 0x61, 0x69, 0x6e, 0x00, 0x00, // export section
            0x0a, 0x04, 0x01, 0x02, 0x00, 0x0b // code section
        ]);
        
        const module = await WebAssembly.instantiate(wasmCode, {
            env: {
                memory: this.memory,
                abort: () => {}
            }
        });
        
        this.modules.set('core', module);
        return module;
    }
    
    async initFilesystem() {
        // Create virtual filesystem using WebKit's FileSystem API
        if (this.webkitFeatures.hasFileSystem) {
            try {
                window.webkitRequestFileSystem(
                    window.TEMPORARY,
                    50 * 1024 * 1024, // 50MB
                    (fs) => {
                        this.virtualFS = fs;
                        logTerminal("‚úÖ Virtual Filesystem: MOUNTED (50MB)");
                        
                        // Create default directories
                        this.createDirectory('/bin');
                        this.createDirectory('/lib');
                        this.createDirectory('/tmp');
                        
                        // Load sample binaries
                        this.loadSampleBinaries();
                    },
                    (e) => {
                        logTerminal(`‚ùå Filesystem Error: ${e.message}`);
                    }
                );
            } catch (e) {
                logTerminal(`‚ö†Ô∏è Using fallback filesystem: ${e.message}`);
                this.virtualFS = new Map(); // Fallback to Map
            }
        }
    }
    
    async executeBinary(binaryData, args = []) {
        if (!this.webkitFeatures.hasWASM) {
            throw new Error("WebAssembly not supported");
        }
        
        const processId = `proc_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        
        logTerminal(`‚öôÔ∏è Starting process ${processId}...`);
        
        try {
            // Create WebAssembly module from binary
            const module = await WebAssembly.compile(binaryData);
            
            // Prepare imports
            const imports = this.createWASMImports(processId);
            
            // Instantiate
            const instance = await WebAssembly.instantiate(module, imports);
            
            // Store process
            const process = {
                id: processId,
                instance: instance,
                memory: this.memory,
                status: 'running',
                startTime: Date.now(),
                exports: instance.exports
            };
            
            this.processes.push(process);
            updateProcessList();
            
            // Execute
            if (instance.exports._start) {
                instance.exports._start();
            } else if (instance.exports.main) {
                const main = instance.exports.main;
                if (typeof main === 'function') {
                    main(args.length, this.createArgv(args));
                }
            }
            
            logTerminal(`‚úÖ Process ${processId} started successfully`);
            return processId;
            
        } catch (error) {
            logTerminal(`‚ùå Execution failed: ${error.message}`);
            throw error;
        }
    }
    
    createWASMImports(processId) {
        return {
            env: {
                memory: this.memory,
                abort: (msg, file, line, col) => {
                    logTerminal(`üõë Process ${processId} aborted: ${msg}`);
                },
                // System calls
                syscall: (num, a1, a2, a3, a4, a5, a6) => {
                    return this.handleSyscall(num, a1, a2, a3, a4, a5, a6, processId);
                },
                // Memory management
                mmap: (addr, len, prot, flags, fd, offset) => {
                    return this.handleMmap(addr, len, prot, flags, fd, offset);
                },
                munmap: (addr, len) => {
                    return this.handleMunmap(addr, len);
                }
            },
            chronos: {
                log: (ptr, len) => {
                    const mem = new Uint8Array(this.memory.buffer);
                    let str = '';
                    for (let i = 0; i < len; i++) {
                        str += String.fromCharCode(mem[ptr + i]);
                    }
                    logTerminal(`[${processId}] ${str}`);
                },
                time: () => Date.now()
            }
        };
    }
    
    handleSyscall(num, a1, a2, a3, a4, a5, a6, processId) {
        // Linux syscall numbers
        const SYS = {
            write: 1,
            read: 0,
            open: 2,
            close: 3,
            brk: 12,
            ioctl: 16,
            mmap: 9,
            munmap: 11,
            execve: 59,
            exit: 60
        };
        
        switch (num) {
            case SYS.write:
                const mem = new Uint8Array(this.memory.buffer);
                let output = '';
                for (let i = 0; i < a3; i++) {
                    output += String.fromCharCode(mem[a2 + i]);
                }
                logTerminal(`[${processId}] ${output}`);
                return a3;
                
            case SYS.exit:
                this.killProcess(processId);
                return 0;
                
            case SYS.brk:
                // Simple heap expansion
                return this.heapExpansion(a1);
                
            default:
                logTerminal(`[${processId}] Syscall ${num} not implemented`);
                return -1;
        }
    }
    
    handleMmap(addr, len, prot, flags, fd, offset) {
        // Simplified mmap implementation
        const PROT = {
            READ: 0x1,
            WRITE: 0x2,
            EXEC: 0x4
        };
        
        const MAP = {
            PRIVATE: 0x02,
            ANONYMOUS: 0x20
        };
        
        if (flags & MAP.ANONYMOUS) {
            // Allocate anonymous memory
            const buffer = new ArrayBuffer(len);
            const view = new DataView(buffer);
            
            // Store mapping
            const mapping = {
                address: Date.now(), // Simplified address
                buffer: buffer,
                length: len,
                prot: prot
            };
            
            this.mappings.push(mapping);
            return mapping.address;
        }
        
        return -1; // Error
    }
    
    heapExpansion(requestedAddr) {
        // Simple heap expansion logic
        const currentHeapEnd = this.heap.byteLength;
        if (requestedAddr > currentHeapEnd) {
            const newSize = Math.max(requestedAddr, currentHeapEnd * 2);
            const newHeap = new ArrayBuffer(newSize);
            
            // Copy old data
            const oldView = new Uint8Array(this.heap);
            const newView = new Uint8Array(newHeap);
            newView.set(oldView);
            
            this.heap = newHeap;
            return requestedAddr;
        }
        
        return requestedAddr;
    }
    
    killProcess(pid) {
        this.processes = this.processes.filter(p => p.id !== pid);
        logTerminal(`üíÄ Process ${pid} terminated`);
        updateProcessList();
    }
    
    createDirectory(path) {
        if (this.virtualFS instanceof Map) {
            this.virtualFS.set(path, { type: 'directory', contents: new Map() });
        } else {
            // Use WebKit FileSystem API
            this.virtualFS.root.getDirectory(path, { create: true }, () => {}, () => {});
        }
    }
    
    loadSampleBinaries() {
        // Add some sample binaries
        this.files.push({
            name: 'hello.bin',
            size: '2.1KB',
            type: 'executable',
            data: null,
            description: 'Simple hello world binary'
        });
        
        this.files.push({
            name: 'sysinfo.bin',
            size: '3.7KB',
            type: 'executable',
            data: null,
            description: 'System information tool'
        });
        
        this.files.push({
            name: 'crypto.bin',
            size: '5.2KB',
            type: 'library',
            data: null,
            description: 'Cryptography library'
        });
        
        updateFileList();
    }
    
    startSystemMonitor() {
        setInterval(() => {
            updateMemoryView();
            updateSystemInfo();
        }, 1000);
    }
}

// ============================================================================
// GLOBALS AND INITIALIZATION
// ============================================================================

const engine = new ChronosEngine();
let currentCommand = '';
let commandHistory = [];
let historyIndex = -1;

// Initialize on page load
window.addEventListener('DOMContentLoaded', async () => {
    await engine.initialize();
    
    // Setup command input
    document.getElementById('commandInput').focus();
    
    // Initial system scan
    scanUSB();
});

// ============================================================================
// TERMINAL FUNCTIONS
// ============================================================================

function logTerminal(message) {
    const terminal = document.getElementById('terminal');
    const line = document.createElement('div');
    line.className = 'terminal-line';
    line.innerHTML = message;
    terminal.appendChild(line);
    terminal.scrollTop = terminal.scrollHeight;
}

function clearTerminal() {
    document.getElementById('terminal').innerHTML = '';
    addPrompt();
}

function addPrompt() {
    const terminal = document.getElementById('terminal');
    const prompt = document.createElement('div');
    prompt.className = 'terminal-line';
    prompt.innerHTML = `<span class="prompt">chronos@webkit:~$</span> <span id="currentCommand"></span><span class="cursor">‚ñà</span>`;
    terminal.appendChild(prompt);
    terminal.scrollTop = terminal.scrollHeight;
}

function handleCommandKey(event) {
    if (event.key === 'Enter') {
        sendCommand();
    } else if (event.key === 'ArrowUp') {
        // History navigation
        if (commandHistory.length > 0 && historyIndex > 0) {
            historyIndex--;
            document.getElementById('commandInput').value = commandHistory[historyIndex];
        }
    } else if (event.key === 'ArrowDown') {
        if (historyIndex < commandHistory.length - 1) {
            historyIndex++;
            document.getElementById('commandInput').value = commandHistory[historyIndex];
        } else {
            document.getElementById('commandInput').value = '';
        }
    }
}

function sendCommand() {
    const input = document.getElementById('commandInput');
    const command = input.value.trim();
    
    if (!command) return;
    
    // Add to history
    commandHistory.push(command);
    historyIndex = commandHistory.length;
    
    // Execute command
    executeCommand(command);
    
    // Clear input
    input.value = '';
}

function executeCommand(cmd) {
    logTerminal(`<span class="prompt">chronos@webkit:~$</span> ${cmd}`);
    
    const parts = cmd.split(' ');
    const command = parts[0].toLowerCase();
    const args = parts.slice(1);
    
    switch (command) {
        case 'help':
            showHelp();
            break;
            
        case 'ls':
            listFiles();
            break;
            
        case 'run':
            if (args.length > 0) {
                runBinary(args[0]);
            } else {
                logTerminal("‚ùå Usage: run <filename>");
            }
            break;
            
        case 'ps':
            listProcesses();
            break;
            
        case 'kill':
            if (args.length > 0) {
                engine.killProcess(args[0]);
            } else {
                logTerminal("‚ùå Usage: kill <pid>");
            }
            break;
            
        case 'mem':
            showMemory();
            break;
            
        case 'clear':
            clearTerminal();
            break;
            
        case 'scan':
            scanUSB();
            break;
            
        case 'mount':
            mountVirtualUSB();
            break;
            
        default:
            logTerminal(`‚ùå Unknown command: ${command}`);
            logTerminal("üí° Type 'help' for available commands");
    }
    
    addPrompt();
}

function showHelp() {
    logTerminal("üìö AVAILABLE COMMANDS:");
    logTerminal("  help                - Show this help message");
    logTerminal("  ls                  - List files in virtual USB");
    logTerminal("  run <file>          - Execute a binary file");
    logTerminal("  ps                  - List running processes");
    logTerminal("  kill <pid>          - Terminate a process");
    logTerminal("  mem                 - Show memory usage");
    logTerminal("  clear               - Clear terminal");
    logTerminal("  scan                - Scan for USB devices");
    logTerminal("  mount               - Mount virtual USB drive");
}

// ============================================================================
// FILE SYSTEM FUNCTIONS
// ============================================================================

function updateFileList() {
    const fileList = document.getElementById('fileList');
    fileList.innerHTML = '';
    
    engine.files.forEach(file => {
        const item = document.createElement('div');
        item.className = 'file-item';
        item.innerHTML = `
            <div style="display: flex; justify-content: space-between;">
                <strong>${file.name}</strong>
                <span style="color: #ffaa00;">${file.size}</span>
            </div>
            <div style="font-size: 0.9rem; color: #cccccc;">${file.description}</div>
        `;
        item.onclick = () => selectFile(file);
        fileList.appendChild(item);
    });
}

function selectFile(file) {
    logTerminal(`üìÑ Selected: ${file.name} (${file.size})`);
    
    // Update command input with run command
    const input = document.getElementById('commandInput');
    input.value = `run ${file.name}`;
    input.focus();
}

async function handleFileSelect(event) {
    const files = event.target.files;
    
    for (let file of files) {
        if (file.name.endsWith('.bin') || file.name.endsWith('.wasm') || file.name.endsWith('.elf')) {
            const reader = new FileReader();
            
            reader.onload = async (e) => {
                const arrayBuffer = e.target.result;
                
                // Add to files list
                engine.files.push({
                    name: file.name,
                    size: formatBytes(file.size),
                    type: 'executable',
                    data: new Uint8Array(arrayBuffer),
                    description: 'Uploaded binary file'
                });
                
                updateFileList();
                logTerminal(`‚úÖ Uploaded: ${file.name} (${formatBytes(file.size)})`);
            };
            
            reader.readAsArrayBuffer(file);
        } else {
            logTerminal(`‚ö†Ô∏è Skipping non-binary file: ${file.name}`);
        }
    }
}

function scanUSB() {
    logTerminal("üîç Scanning for USB devices...");
    
    // Simulate USB detection
    setTimeout(() => {
        if (engine.webkitFeatures.hasWebUSB) {
            logTerminal("‚úÖ WebUSB API available");
            logTerminal("üì¶ Virtual USB detected: CHRONOS_VUSB_0x1A2B");
            logTerminal("üíæ Capacity: 32GB | Filesystem: FAT32");
            
            updateStatus("üü¢ USB CONNECTED");
        } else {
            logTerminal("‚ö†Ô∏è WebUSB not supported in this browser");
            logTerminal("üì¶ Using virtual USB emulation");
            
            updateStatus("üü° VIRTUAL USB");
        }
        
        listFiles();
    }, 1000);
}

function mountVirtualUSB() {
    logTerminal("üîß Mounting virtual USB drive...");
    
    // Create virtual USB with sample files
    engine.loadSampleBinaries();
    
    logTerminal("‚úÖ Virtual USB mounted successfully");
    logTerminal("üìÅ Files available in left panel");
}

function listFiles() {
    if (engine.files.length === 0) {
        logTerminal("üìÅ No files found in USB");
    } else {
        logTerminal("üìÅ Files in USB:");
        engine.files.forEach(file => {
            logTerminal(`  ${file.name.padEnd(20)} ${file.size.padStart(10)}`);
        });
    }
}

async function runBinary(filename) {
    const file = engine.files.find(f => f.name === filename);
    
    if (!file) {
        logTerminal(`‚ùå File not found: ${filename}`);
        return;
    }
    
    if (!file.data) {
        logTerminal(`‚ö†Ô∏è Binary data not loaded for: ${filename}`);
        logTerminal("üí° Please upload the file first");
        return;
    }
    
    try {
        await engine.executeBinary(file.data, [filename]);
    } catch (error) {
        logTerminal(`‚ùå Failed to execute ${filename}: ${error.message}`);
    }
}

// ============================================================================
// SYSTEM MONITOR FUNCTIONS
// ============================================================================

function updateMemoryView() {
    const viewer = document.getElementById('memoryViewer');
    
    // Generate fake memory view for demonstration
    let html = '';
    const baseAddress = 0x1000;
    
    for (let i = 0; i < 20; i++) {
        const address = baseAddress + (i * 16);
        const hex = generateRandomHex(16);
        const ascii = hexToAscii(hex);
        
        html += `
            <div class="memory-line">
                <span class="memory-address">0x${address.toString(16).padStart(8, '0')}</span>
                <span class="memory-hex">${hex}</span>
                <span class="memory-ascii">${ascii}</span>
            </div>
        `;
    }
    
    viewer.innerHTML = html;
}

function updateProcessList() {
    const list = document.getElementById('processList');
    list.innerHTML = '';
    
    engine.processes.forEach(proc => {
        const uptime = ((Date.now() - proc.startTime) / 1000).toFixed(1);
        const item = document.createElement('div');
        item.style = "padding: 5px; margin: 3px 0; background: rgba(0,0,0,0.3); border-radius: 3px;";
        item.innerHTML = `
            <div style="display: flex; justify-content: space-between;">
                <span>${proc.id}</span>
                <span style="color: #00ff00;">${proc.status}</span>
            </div>
            <div style="font-size: 0.8rem; color: #cccccc;">Uptime: ${uptime}s</div>
        `;
        list.appendChild(item);
    });
}

function updateSystemInfo() {
    // Update memory usage
    const usedMB = (engine.memory.buffer.byteLength / (1024 * 1024)).toFixed(1);
    const heapMB = (engine.heap.byteLength / (1024 * 1024)).toFixed(1);
    
    // Update status bar
    const status = document.getElementById('status');
    const security = document.getElementById('security');
    
    if (engine.processes.length > 0) {
        status.innerHTML = `üü¢ ${engine.processes.length} PROCESSES`;
    }
    
    // Toggle security status based on activity
    if (engine.isRunning) {
        security.innerHTML = '‚ö†Ô∏è EXECUTION ACTIVE';
        security.style.background = 'rgba(255, 170, 0, 0.2)';
        security.style.borderColor = '#ffaa00';
    }
}

function listProcesses() {
    if (engine.processes.length === 0) {
        logTerminal("üìä No processes running");
    } else {
        logTerminal("üìä Active Processes:");
        engine.processes.forEach(proc => {
            const uptime = ((Date.now() - proc.startTime) / 1000).toFixed(1);
            logTerminal(`  ${proc.id.padEnd(20)} ${proc.status.padStart(10)} ${uptime}s`);
        });
    }
}

function showMemory() {
    const used = engine.memory.buffer.byteLength;
    const heap = engine.heap.byteLength;
    const stack = engine.stack.byteLength;
    
    logTerminal("üß† MEMORY USAGE:");
    logTerminal(`  WebAssembly Memory: ${formatBytes(used)}`);
    logTerminal(`  Heap: ${formatBytes(heap)}`);
    logTerminal(`  Stack: ${formatBytes(stack)}`);
    logTerminal(`  Total: ${formatBytes(used + heap + stack)}`);
}

function killProcess() {
    if (engine.processes.length > 0) {
        const proc = engine.processes[engine.processes.length - 1];
        engine.killProcess(proc.id);
        logTerminal(`üíÄ Terminated process: ${proc.id}`);
    } else {
        logTerminal("‚ö†Ô∏è No processes to kill");
    }
}

function toggleExecution() {
    engine.isRunning = !engine.isRunning;
    const btn = document.getElementById('execBtn');
    
    if (engine.isRunning) {
        btn.innerHTML = '‚ñ∂Ô∏è RESUME';
        logTerminal("‚è∏Ô∏è Execution paused");
    } else {
        btn.innerHTML = '‚è∏Ô∏è PAUSE';
        logTerminal("‚ñ∂Ô∏è Execution resumed");
    }
}

function refreshMemory() {
    updateMemoryView();
    logTerminal("üîÑ Memory view refreshed");
}

function updateStatus(message) {
    const status = document.getElementById('status');
    status.innerHTML = message;
    
    if (message.includes('ONLINE') || message.includes('CONNECTED')) {
        status.style.background = 'rgba(0, 255, 0, 0.2)';
        status.style.borderColor = '#00ff00';
    }
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

function formatBytes(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
}

function generateRandomHex(length) {
    let hex = '';
    for (let i = 0; i < length; i += 2) {
        hex += Math.floor(Math.random() * 256).toString(16).padStart(2, '0') + ' ';
    }
    return hex.trim();
}

function hexToAscii(hex) {
    const bytes = hex.split(' ').filter(Boolean);
    let ascii = '';
    
    for (let byte of bytes) {
        const charCode = parseInt(byte, 16);
        if (charCode >= 32 && charCode <= 126) {
            ascii += String.fromCharCode(charCode);
        } else {
            ascii += '.';
        }
    }
    
    return ascii.padEnd(16, ' ');
}

function detectWebKitVersion() {
    const ua = navigator.userAgent;
    
    if (ua.includes('AppleWebKit')) {
        const match = ua.match(/AppleWebKit\/([\d.]+)/);
        if (match) {
            return match[1];
        }
    }
    
    // Check for Safari
    if (ua.includes('Safari') && !ua.includes('Chrome')) {
        return 'Safari WebKit';
    }
    
    // Check for Chrome's Blink (WebKit fork)
    if (ua.includes('Chrome')) {
        const chromeMatch = ua.match(/Chrome\/([\d.]+)/);
        if (chromeMatch) {
            return `Chrome ${chromeMatch[1]} (Blink/WebKit)`;
        }
    }
    
    return 'Unknown WebKit';
}

// ============================================================================
// INITIAL PROMPT
// ============================================================================

// Add initial prompt
setTimeout(() => {
    addPrompt();
}, 100);

// Focus command input on click anywhere
document.body.addEventListener('click', () => {
    document.getElementById('commandInput').focus();
});
</script>
</body>
</html>
